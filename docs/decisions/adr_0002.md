# ADR 0002: Responsive 3D Cube and HTML Face Sizing System

**Status:** Accepted
**Date:** 2025-01-29
**Decision Makers:** Development Team
**Related ADRs:** ADR 0001 (to be documented retrospectively)

---

## Context and Problem Statement

Our portfolio application features a 3D cube with HTML faces (representing different pages: chat, resume, projects, etc.) rendered using React Three Fiber and Drei's `<Html>` component. We encountered fundamental scaling inconsistencies:

### The Core Problem

**Two related but misaligned sizing systems:**

1. **3D Cube:** Sized in Three.js world units, screen-space size = worldUnits × (windowHeight / viewportHeightUnits)
2. **HTML Faces:** Sized in CSS pixels with `distanceFactor` creating coupling to 3D world space

### Symptoms Observed

1. **Continuous scaling:** As window height changed, the cube's screen-space size changed proportionally (not desired)
2. **Misalignment:** Cube faces and HTML divs had different screen sizes, creating visual inconsistency
3. **Confusing scaling:** `scale={0.25}` on Html × `scale-200` Tailwind class = double-scaling complexity
4. **No breakpoint system:** Sizes changed continuously rather than at discrete breakpoints like responsive CSS

### Technical Analysis

#### World Units to Pixels Relationship

For a PerspectiveCamera with FOV θ at distance D:

```
viewportHeightInUnits = 2 × D × tan(θ/2)
pixelsPerUnit = windowHeight / viewportHeightInUnits
cubeScreenPixels = cubeWorldUnits × pixelsPerUnit
```

**Example from our logs:**
- Window: 1305px height
- Camera distance: 22.6 units
- FOV: 50°
- Viewport: 18.65 units tall
- Pixels per unit: 1305 / 18.65 ≈ 70 px/unit
- 10-unit cube: 10 × 70 = **700px on screen**

**When window shrinks to 900px:**
- Viewport units: 18.65 units (unchanged - same camera distance)
- Pixels per unit: 900 / 18.65 ≈ 48 px/unit
- 10-unit cube: 10 × 48 = **480px on screen**

**This causes continuous scaling** - the cube's screen size changes proportionally with window size even though its world size is constant.

#### HTML Face Sizing

Working implementation discovered empirically:
```typescript
// Face.tsx
faceSize atom = 800px
  ↓
<div width={800px} height={800px}>
  ↓ Tailwind scale-200 (transform: scale(2))
  → 1600px × 1600px
  ↓ Html scale={0.5}
  → 800px × 800px
  ↓ distanceFactor={5} creates world-space coupling
  → matches cube projection perfectly
```

**Key Discovery:** `distanceFactor` is NOT 0 - it creates a scaling relationship that ties HTML to world-space, making cube and faces align automatically.

#### Why Drei's `<Bounds>` Didn't Work

We attempted using Drei's `<Bounds>` component to auto-fit the camera, but discovered:

1. **Bounds adjusts camera distance** dynamically to frame objects
2. **Interactive controls (OrbitControls)** allow user to override Bounds' positioning
3. **Result:** Camera position becomes unpredictable, breaking precise sizing
4. **margin parameter** works backwards from intuition (margin=0.1 makes object huge, not small)

Bounds is designed for "focus on object when needed," not "maintain exact pixel sizes at breakpoints."

The solution: **Manual control** of camera distance combined with correct `distanceFactor` value.

---

## Decision Drivers

- **Pixel-perfect alignment:** Cube and HTML faces must appear exactly the same size on screen
- **Discrete breakpoints:** Sizing should change at breakpoints (mobile/tablet/desktop), not continuously
- **Single source of truth:** One configuration defines all sizing, eliminating conflicts
- **Simplicity:** Remove double-scaling complexity and unnecessary abstractions
- **Maintainability:** Clear, documented relationship between world units and pixels
- **Consistency with CSS patterns:** Behave like standard responsive CSS

---

## Considered Options

### Option 1: Hybrid Approach (TypeScript Config + Inline Styles + CSS) ✓ SELECTED

**Architecture:**
```
RESPONSIVE_CONFIG (TypeScript)
  → targetPixelSize (single source of truth)
      ↓
  ┌───────────┴────────────┐
  ↓                        ↓
faceSizeAtom          cubeSizeAtom
(CSS pixels)         (world units, calculated)
  ↓                        ↓
Face inline styles   Cube geometry
  ↓                        ↓
800px on screen  ←  800px on screen
```

**Components:**

1. **Breakpoint Config (`src/config/responsive.ts`):**
   ```typescript
   export const RESPONSIVE_CONFIG = {
     mobile: {
       minWidth: 0,
       maxWidth: 767,
       targetPixelSize: 400,    // SINGLE SOURCE OF TRUTH
       cameraDistance: 18,
     },
     desktop: {
       minWidth: 1024,
       maxWidth: Infinity,
       targetPixelSize: 800,
       cameraDistance: 25,
     },
   };
   ```

2. **Responsive Hook (`src/hooks/useResponsiveBreakpoint.ts`):**
   - Listens to window resize (debounced 150ms)
   - Determines breakpoint based on `window.innerWidth`
   - **ONLY updates atoms when breakpoint changes** (not continuously)
   - Calculates cube size using inverse formula:
     ```typescript
     cubeSize = (targetPixelSize / windowHeight) × viewportHeightUnits
     ```

3. **Jotai Atoms (state management):**
   ```typescript
   cubeSizeAtom        // World units (calculated)
   faceSizeAtom        // CSS pixels (from config)
   cameraDistanceAtom  // Fixed per breakpoint
   currentBreakpointAtom // 'mobile' | 'tablet' | 'desktop'
   ```

4. **Styling approach:**
   - **Static styles:** `globals.css` for colors, borders, shadows
   - **Dynamic sizing:** Inline styles from atoms (`width: ${faceSize}px`)
   - **Responsive styling:** Tailwind classes (`text-sm md:text-lg`)

**Simplifications:**
- Remove `useAspect` (unused, incorrect for this use case)
- Keep Html `scale={0.5}` (working baseline value)
- Keep Tailwind `scale-200` (working with Html scale=0.5)
- Remove `useResponsiveFaceSize` hook (replaced)
- Remove `CameraController` component (camera from atom)
- Use `distanceFactor={5}` as baseline (creates world-space coupling)

### Option 2: CSS Variables as Source of Truth

```css
:root {
  --target-size-mobile: 400px;
  --target-size-desktop: 800px;
}
```

JavaScript reads these via `getComputedStyle()`.

**Rejected because:**
- Adds indirection (CSS → JS → atoms → components)
- Can't do mathematical calculations in CSS alone
- More complex than direct TypeScript config

### Option 3: Dynamic Tailwind Classes

```typescript
<div className={cn(
  breakpoint === 'mobile' && 'w-[400px] h-[400px]',
  breakpoint === 'desktop' && 'w-[800px] h-[800px]',
)}>
```

**Rejected because:**
- Can't dynamically calculate cube world units this way
- Less type-safe than atoms
- Mixes styling logic with component logic

---

## Decision Outcome

**Chosen option: Option 1 (Hybrid Approach)**

### Breakpoint Strategy

**Desktop/Tablet (Height-Based Breakpoints):**
- **desktopLarge** (h ≥ 1200px): 800px cube, controls visible
- **desktopMedium** (h ≥ 1000px): 700px cube, controls visible
- **tabletLandscape** (h ≥ 800px): 650px cube, controls visible
- Height determines which breakpoint, width affects CSS padding only
- Example: 912×1368 tablet portrait → height >1200 → 800px cube with horizontal padding

**Mobile (Percentage-Based, Device-Detected):**
- Portrait: cubeSize = windowHeight × 0.9 (10% margins)
- Landscape: cubeSize = windowWidth × 0.9 (10% margins)
- Controls moved to Drawer component
- Dynamic per device (no fixed sizes)

**Critical Behavior:**
- Cube size changes ONLY at breakpoint boundaries
- Within breakpoint: camera distance adjusts continuously to maintain exact pixel size
- Natural perspective scaling is cancelled by compensating camera movement

### Implementation Plan

#### Phase 1: Core Infrastructure
1. Create `src/config/responsive.ts` with breakpoint definitions
2. Add new atoms to `src/atoms/atomStore.ts`
3. Create `src/hooks/useResponsiveBreakpoint.ts`

#### Phase 2: Component Updates
4. Modify `Scene.tsx`: Use hook, read camera position from atom
5. Simplify `CubeWithFaces.tsx`: Remove useAspect, set Html scale=1
6. Simplify `Face.tsx`: Direct sizing from faceSizeAtom
7. Add static styles to `globals.css`

#### Phase 3: Cleanup
8. Delete `src/hooks/useResponsiveFaceSize.ts`
9. Delete `src/components/scene/CameraController.tsx`
10. Remove all `scale-200` Tailwind classes from Face content

### Data Flow

```
Window Resize Event
        ↓
useResponsiveBreakpoint (debounced 150ms)
        ↓
Detect breakpoint (mobile device check → height-based for desktop/tablet)
        ↓
[If breakpoint changed - DISCRETE UPDATE]
        ↓
Get RESPONSIVE_CONFIG[breakpoint]
  - targetPixelSize (e.g., 800px)
  - controlsLayout ('visible' or 'drawer')
        ↓
Calculate:
  - cameraDistance = f(cubeWorldSize, targetPixelSize, windowHeight, fov)
  - distanceFactor = f(cameraDistance, targetPixelSize) [empirical]
  - cubeSize in world units
        ↓
Update ALL atoms:
  - cubeSizeAtom ← world units
  - faceSizeAtom ← targetPixelSize
  - cameraDistanceAtom ← calculated distance
  - distanceFactorAtom ← calculated factor
  - currentBreakpointAtom ← breakpoint key
  - controlsLayoutAtom ← 'visible' | 'drawer'
        ↓
[If within same breakpoint - CONTINUOUS COMPENSATION]
        ↓
Recalculate camera distance only:
  - New windowHeight → new cameraDistance
  - Update cameraDistanceAtom
  - Maintains exact targetPixelSize on screen
        ↓
Components re-render:
  - Scene: camera position updates
  - CubeWithFaces: reads distanceFactor, htmlScale
  - Face: applies calc() padding when viewport narrow
        ↓
Result: Cube and Html exactly match targetPixelSize at all times
```

### Positive Consequences

- **Pixel-perfect alignment:** Cube and HTML faces match exactly on screen
- **Predictable behavior:** Changes only at breakpoints, not continuously
- **Single source of truth:** `targetPixelSize` in config controls everything
- **Simplified code:** No double-scaling, no unused hooks
- **Type-safe:** TypeScript ensures correctness
- **Maintainable:** Clear relationship documented between world units and pixels
- **Familiar pattern:** Works like CSS media queries

### Negative Consequences

- **Requires recalculation:** On window resize, cube size must be recalculated
- **Window height dependency:** Cube world size varies with window height within a breakpoint
- **Slight inaccuracy:** Perspective projection may cause 1-2px variation

### Mitigation

- **Debouncing:** 150ms delay prevents excessive calculations
- **Height variation acceptable:** Within breakpoint range, slight size changes are tolerable
- **Accuracy acceptable:** 1-2px variation is imperceptible to users

---

## Validation

### Test Scenarios

1. **Breakpoint transitions:**
   - Desktop (1920×1080) → 800px cube and faces ✓
   - Resize to tablet (768×1024) → 600px cube and faces ✓
   - Resize to mobile (375×667) → 400px cube and faces ✓

2. **Within-breakpoint behavior:**
   - Desktop 1920×1080 → Desktop 1440×900
   - Cube world size adjusts, screen size stays ~800px ±5px ✓

3. **Loading state:**
   - App starts with `isLoaded=false`
   - Hook calculates initial breakpoint
   - Sets all atoms
   - Sets `isLoaded=true`, scene fades in ✓

### Success Metrics

- Cube and face screen sizes match within 5px
- No continuous scaling during window resize
- Only 3 size updates per session (breakpoint changes)
- Clean console logs showing breakpoint transitions

---

## Links and References

- [React Three Fiber - useThree API](https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree)
- [Drei - Html Component](https://github.com/pmndrs/drei#html)
- [Three.js - PerspectiveCamera](https://threejs.org/docs/#api/en/cameras/PerspectiveCamera)
- Jotai Atoms Documentation
- ADR 0001: [To be documented retrospectively]

---

## Notes

### Mathematical Derivation

**Forward calculation (world units → screen pixels):**
```
screenPixels = worldUnits × (windowHeight / viewportHeightUnits)
```

**Inverse calculation (screen pixels → world units):**
```
worldUnits = screenPixels × (viewportHeightUnits / windowHeight)

where:
  viewportHeightUnits = 2 × cameraDistance × tan(fov/2)

therefore:
  worldUnits = (screenPixels / windowHeight) × (2 × cameraDistance × tan(fov/2))
```

This is the formula used in `calculateCubeSizeForBreakpoint()`.

### Why distanceFactor={5} is Correct

From Drei docs:
> "distanceFactor: If set, children will be scaled by this factor, and also by distance to camera"

Setting `distanceFactor={5}` creates **world-space coupling**:
- HTML faces scale proportionally with camera distance
- At distance 25, factor 5 creates the scaling relationship that makes 800px CSS match 800px cube projection
- When camera moves closer/farther (within breakpoint compensation), HTML scales accordingly
- This maintains alignment automatically

**Empirical Discovery:**
Through testing, `distanceFactor={5}` with `htmlScale={0.5}` and `scale-200` CSS creates perfect alignment at our baseline (distance ~25, size 800px).

### Why distanceFactor={0} Doesn't Work

Setting `distanceFactor={0}` **disables world-space coupling**:
- HTML becomes fixed in screen-space pixels regardless of camera distance
- When camera adjusts to compensate for window height changes, cube projection changes but HTML stays fixed
- Results in misalignment: cube 700px, HTML 800px (or vice versa)
- Requires completely different calculation strategy (calculate cube size instead of camera distance)

---

**This ADR represents our definitive solution to the responsive 3D/2D sizing problem.**