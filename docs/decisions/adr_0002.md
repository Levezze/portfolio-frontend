# ADR 0002: Responsive 3D Cube and HTML Face Sizing System

**Status:** Accepted (Revised)
**Date:** 2025-01-29 (Updated: 2025-01-30)
**Decision Makers:** Development Team
**Related ADRs:** ADR 0001 (to be documented retrospectively)

---

## Context and Problem Statement

Our portfolio application features a 3D cube with HTML faces (representing different pages: chat, resume, projects, etc.) rendered using React Three Fiber and Drei's `<Html>` component. We encountered fundamental scaling inconsistencies that required multiple iterations to solve.

### The Core Problem

**Two related but misaligned sizing systems:**

1. **3D Cube:** Sized in Three.js world units
2. **HTML Faces:** Sized in CSS pixels

### Root Cause: PerspectiveCamera Responsiveness

With PerspectiveCamera, the cube size on screen is inherently coupled to viewport height:

```
screenPixels = worldUnits × (windowHeight / viewportHeightUnits)
```

**This means:**
- Window height changes → cube screen size changes
- No way to prevent this with PerspectiveCamera
- Attempts to compensate with camera distance adjustments created complex, brittle systems

### Failed Approaches

1. **Dynamic camera distance calculation** - Complex formulas, stale closures, linear resizing
2. **distanceFactor formulas** - Inverted ratios, broken at different breakpoints
3. **Responsive hooks** - Multiple systems fighting each other, unpredictable behavior

---

## Decision Outcome

### Chosen Solution: OrthographicCamera + CSS Breakpoints

**Key insight:** OrthographicCamera provides **fixed world-to-pixel mapping** independent of viewport size.

**Formula:**
```
screenPixels = worldUnits × zoom
```

**Simple. Predictable. Stable.**

### Implementation

**1. Fixed Camera Setup:**
```tsx
<OrthographicCamera
  makeDefault
  position={[0, 0, 100]}
  zoom={100}  // FIXED, never changes
/>
```

**2. CSS Breakpoints Define Target Sizes:**
```css
:root {
  --face-size: 400px;  /* Default: < 600x600 */
}

@media (min-width: 600px) and (min-height: 600px) {
  :root {
    --face-size: 500px;
  }
}

@media (min-width: 800px) and (min-height: 800px) {
  :root {
    --face-size: 650px;
  }
}

@media (min-width: 1000px) and (min-height: 1000px) {
  :root {
    --face-size: 800px;
  }
}
```

**3. Cube World Size Adjusts Per Breakpoint:**
```typescript
// atomStore.ts
export const cubeSizeAtom = atom<number>(8);  // 800px ÷ 100 = 8 world units

// For 650px: cubeSizeAtom = 6.5
// For 500px: cubeSizeAtom = 5.0
// For 400px: cubeSizeAtom = 4.0
```

**4. HTML Uses distanceFactor for Alignment:**
```tsx
<Html
  distanceFactor={4}  // Empirically determined
  transform
  occlude
>
  <div className="cube-face">  // CSS: width/height from --face-size
    {content}
  </div>
</Html>
```

### Data Flow

```
CSS Breakpoint Triggers
        ↓
--face-size CSS variable updates (800px → 650px → 500px)
        ↓
React hook reads CSS variable
        ↓
Updates cubeSizeAtom (8 → 6.5 → 5)
        ↓
Cube geometry updates: <boxGeometry args={[cubeSize, cubeSize, cubeSize]} />
        ↓
Result: Cube screen size = cubeSize × zoom = 6.5 × 100 = 650px ✓
```

### Why This Works

**OrthographicCamera advantages:**
- Fixed zoom = fixed pixel ratio
- No perspective distortion
- Window resize does nothing (unless breakpoint changes)
- Simple formula: `targetSize = worldUnits × zoom`

**CSS breakpoints advantages:**
- Standard responsive pattern
- Discrete changes only
- No JavaScript resize listeners needed
- Browser handles all detection

**distanceFactor role:**
- With OrthographicCamera, distanceFactor creates scaling relationship
- Value determined empirically per zoom level
- Keeps HTML aligned with cube faces

---

## Consequences

### Positive

- **Zero continuous scaling** - Size only changes at CSS breakpoints
- **Simple formula** - `screenPixels = worldUnits × zoom`
- **No JavaScript resize logic** - CSS handles everything
- **Predictable behavior** - Orthographic = no perspective surprises
- **Maintainable** - Clear relationship between values
- **Performant** - No recalculations on every resize

### Negative

- **No perspective depth** - Orthographic camera has no vanishing point (acceptable trade-off)
- **Manual breakpoint sync** - Must update both CSS and atom when adding breakpoints
- **Empirical distanceFactor** - Value must be tested per zoom level

### Migration Notes

**Removed systems:**
- `useResponsiveFaceSize` hook (disabled, CSS handles it)
- `CameraController` camera adjustment logic (commented out)
- Dynamic camera distance calculations
- distanceFactor formulas
- All perspective-based compensation logic

**Key files:**
- `src/app/globals.css` - CSS breakpoints with `--face-size`
- `src/atoms/atomStore.ts` - `cubeSizeAtom` for world units
- `src/components/Scene.tsx` - OrthographicCamera with fixed zoom
- `src/components/scene/CubeWithFaces.tsx` - distanceFactor={4}

---

## Validation

### Success Criteria

- ✅ Cube and HTML faces match exactly (±2px tolerance)
- ✅ No size changes when resizing within same breakpoint
- ✅ Discrete size changes only at CSS breakpoint boundaries
- ✅ No JavaScript resize listeners needed
- ✅ Simple, maintainable formula

### Breakpoints

| Viewport Size (W×H) | --face-size | cubeSizeAtom | Result |
|---------------------|-------------|--------------|---------|
| ≥ 1000×1000         | 800px       | 8.0          | 800px   |
| ≥ 800×800           | 650px       | 6.5          | 650px   |
| ≥ 600×600           | 500px       | 5.0          | 500px   |
| < 600×600           | 400px       | 4.0          | 400px   |

Formula validation: `screenPixels = cubeSizeAtom × zoom = cubeSizeAtom × 100`

**Note:** Breakpoints require BOTH minimum width AND minimum height to prevent cube oversizing on extreme aspect ratios.

---

## Links and References

- [Three.js - OrthographicCamera](https://threejs.org/docs/#api/en/cameras/OrthographicCamera)
- [Drei - OrthographicCamera](https://github.com/pmndrs/drei#orthographiccamera)
- [CSS Custom Properties (Variables)](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties)

---

## Lessons Learned

1. **PerspectiveCamera is inherently responsive** - Cannot be made fixed without complex compensation
2. **OrthographicCamera is the right tool** for fixed-size 3D UI elements
3. **CSS breakpoints are better than JS resize listeners** - Leverage browser capabilities
4. **Simpler is better** - Complex formulas and multiple systems create brittleness
5. **Empirical testing beats theoretical calculations** - distanceFactor must be tested

**The key revelation:** Stop fighting perspective camera's natural behavior. Use orthographic instead.