# ADR 0003: Browser Navigation System for State-Based Application

**Status:** Accepted
**Date:** 2025-10-07
**Decision Makers:** Development Team
**Related ADRs:** ADR 0002 (Responsive 3D Cube System)

---

## Context and Problem Statement

Our portfolio application uses a 3D cube to display different pages (chat, resume, projects, contact, blog, secret) as faces on a rotating cube. Navigation between pages is handled entirely through Jotai state (`activeFaceAtom`) rather than Next.js routing or URL changes. Additionally, the app has multiple layers of UI state that users can navigate through:

1. **Page/Face changes** - Rotating the cube to show different faces
2. **Dialog openings** - Project details, fullscreen media viewers
3. **Chat thread state** - Starting new conversations

### The Core Problem

**Without URL-based routing, the browser back button has no navigation history to traverse.** When users press back (via browser button, mouse button 4, or mobile gestures), the default behavior is to exit the application entirely, creating a poor user experience.

### Requirements

The solution must:

1. **Prevent app exit** - Back button should never leave the application
2. **Reverse state changes** - Each back press should undo the previous user action in LIFO (Last In, First Out) order
3. **Support multiple navigation types** - Page changes, dialogs, and chat threads
4. **Work with all back mechanisms** - Browser buttons, mouse shortcuts, mobile gestures, and keyboard shortcuts
5. **Coordinate with browser history** - Maintain synchronization between internal state and browser history API

### Technical Constraints

- **No URL routing** - State changes don't modify the URL
- **Multiple state sources** - Jotai atoms, React component state, and dialog state
- **Next.js SSR** - Must work in both server and client environments
- **Browser History API limitations** - Can't directly prevent back navigation, must work around it

---

## Failed Approaches

Through iterative development, several approaches were attempted and failed:

### 1. Component-Level Navigation Hooks

**Approach:** Created `useNavigationStack` hook used in multiple components (`CubeWithFaces`, `Projects`, `MediaGallery`, `thread`).

**Problem:**
- Race conditions between multiple hook instances
- Coordination issues - components couldn't see each other's navigation state
- Timing problems - callbacks pushed in wrong order
- Fragile and hard to debug

**User feedback:** *"I don't think that placing this hook in every component is good design. It should wrap the app, and execute the necessary command when prompted."*

### 2. No Direction Tracking

**Approach:** Track face changes by watching `activeFaceAtom` and automatically push callbacks whenever it changes.

**Problem:**
- **Infinite loops** - System couldn't distinguish between:
  - User clicking "Projects" button (forward navigation → should push callback)
  - Callback executing `setActiveFace("chat")` (backward navigation → should NOT push callback)
- Both looked identical as state updates, causing endless ping-pong: `chat → projects → contact → projects → contact → projects...`

**User feedback:** *"Endless loop. chat → projects → contact : pressing back goes to projects, pressing again goes to contact again, endless loop"*

### 3. Callbacks Using Write-Only Atoms

**Approach:** Callbacks tried to navigate using `set(navigateToFaceAtom, { face: "chat", direction: "backward" })`

**Problem:**
- In Jotai, write-only atoms (with `null` as first parameter) are **actions, not values**
- You can't "set" a write-only atom's value - calling the setter executes the write function
- Callbacks executed but nothing happened because they tried to set a non-existent read value
- Console showed execution logs but no visual state changes

**User feedback:** *"Now nothing works. Pressing back does NOTHING... This is completely broken."*

### 4. Initial Dummy History Entries

**Approach:** Push dummy history states on app initialization to create a navigation buffer.

**Problem:**
- Next.js detected state changes in these dummy entries
- Triggered full page refreshes when navigating back to initial state
- Conflicts with Next.js internal routing state management

**User feedback:** *"Whenever we 'back' to 'chat' (the first page), it refreshes the page. Why?"*

---

## Decision Outcome

### Chosen Solution: Centralized Navigation Manager with Callback Stack

**Architecture:**
- **GlobalNavigationManager** - Single component at app root that coordinates all navigation
- **Explicit direction parameter** - Navigation actions specify `direction: "forward" | "backward"`
- **Callback stack** - LIFO queue storing undo functions for each navigation action
- **Browser history synchronization** - History entries pushed when stack grows, consumed on popstate

### Implementation

**1. State Management (atomStore.ts)**

```typescript
// Navigation stack stores callbacks with metadata
export type NavigationStackItem = {
  callback: () => void;
  label?: string;
  timestamp: number;
};

export const navigationStackAtom = atom<NavigationStackItem[]>([]);

// Write-only atom for page navigation with explicit direction
export const navigateToFaceAtom = atom(
  null,
  (get, set, update: { face: PagesType; direction: "forward" | "backward" }) => {
    const previousFace = get(activeFaceAtom);

    // Always update the face
    set(activeFaceAtom, update.face);

    // Only push to navigation stack on forward navigation
    if (update.direction === "forward" && previousFace !== update.face) {
      set(navigationStackAtom, (prev) => [
        ...prev,
        {
          // Callback directly updates activeFaceAtom (NOT through navigateToFaceAtom)
          callback: () => set(activeFaceAtom, previousFace),
          label: `Return to ${previousFace} page`,
          timestamp: Date.now(),
        },
      ]);
    }
  }
);

// Write-only atom for pushing callbacks (dialogs, modals, etc.)
export const pushNavigationCallbackAtom = atom(
  null,
  (get, set, update: { callback: () => void; label?: string }) => {
    set(navigationStackAtom, (prev) => [
      ...prev,
      {
        ...update,
        timestamp: Date.now(),
      },
    ]);

    // Also push browser history state to keep synchronized
    if (typeof window !== "undefined") {
      window.history.pushState(
        { navId: `action-${Date.now()}`, managed: true },
        "",
        window.location.href
      );
    }
  }
);
```

**2. Centralized Navigation Manager (GlobalNavigationManager.tsx)**

```typescript
export const GlobalNavigationManager = () => {
  const stack = useAtomValue(navigationStackAtom);
  const setStack = useSetAtom(navigationStackAtom);

  // Ref pattern: access current stack without recreating handler
  const stackRef = useRef(stack);
  stackRef.current = stack;

  const previousStackLengthRef = useRef(stack.length);

  // Push browser history when stack grows (forward navigation)
  useEffect(() => {
    if (stack.length > previousStackLengthRef.current && typeof window !== "undefined") {
      window.history.pushState(
        { navId: `nav-${Date.now()}`, managed: true },
        "",
        window.location.href
      );
    }
    previousStackLengthRef.current = stack.length;
  }, [stack.length]);

  // Listen for popstate events (stable handler with stackRef)
  useEffect(() => {
    if (typeof window === "undefined") return;

    const handlePopState = (event: PopStateEvent) => {
      const currentStack = stackRef.current;

      if (currentStack.length > 0) {
        // Pop and execute the most recent callback
        setStack((prev) => {
          if (prev.length === 0) return prev;

          const item = prev[prev.length - 1];

          try {
            item.callback();
          } catch (error) {
            console.error("[Navigation] Error executing callback:", error);
          }

          return prev.slice(0, -1);
        });

        // DON'T push forward - let browser naturally handle back navigation
      } else {
        // Stack is empty - prevent app exit by pushing forward
        window.history.pushState(
          { navId: `trap-${Date.now()}`, managed: true },
          "",
          window.location.href
        );
      }
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, [setStack]); // Only recreate if setStack changes (effectively never)

  return null;
};
```

**3. Usage in Components**

```typescript
// Page navigation (Navigation.tsx)
const navigateToFace = useSetAtom(navigateToFaceAtom);

handleClick={() => {
  navigateToFace({ face: "projects", direction: "forward" });
}}

// Dialog navigation (Projects.tsx, MediaGallery.tsx)
const pushCallback = useSetAtom(pushNavigationCallbackAtom);

const handleOpenChange = (open: boolean) => {
  setIsOpen(open);
  if (open) {
    pushCallback({
      callback: () => setIsOpen(false),
      label: `Close ${project.title}`,
    });
  }
};

// Chat thread navigation (thread.tsx)
const pushCallback = useSetAtom(pushNavigationCallbackAtom);
const hasPushedCallbackRef = useRef(false);

useEffect(() => {
  const hasMessages = thread.messages && thread.messages.length > 0;

  if (hasMessages && !hasPushedCallbackRef.current) {
    pushCallback({
      callback: () => runtime.switchToNewThread(),
      label: "Start new chat",
    });
    hasPushedCallbackRef.current = true;
  }
}, [thread.messages, runtime, pushCallback]);
```

**4. Mounted in Root Layout (layout.tsx)**

```typescript
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <GlobalNavigationManager />
        <ThemeWrapper>{children}</ThemeWrapper>
      </body>
    </html>
  );
}
```

### Why This Works

**Explicit Direction Parameter:**
- Components specify intent: `direction: "forward"` vs `"backward"`
- Prevents infinite loops - callbacks execute without triggering new callbacks
- Clear semantics - forward navigation pushes, backward navigation doesn't

**Centralized Manager:**
- Single source of truth for navigation coordination
- No race conditions between components
- Easy to debug with centralized logging

**Callback Stack (LIFO):**
- Each forward action pushes an undo callback
- Back button pops and executes most recent callback
- Natural undo/redo behavior

**Browser History Synchronization:**
- Stack growth triggers `history.pushState()`
- Popstate events trigger callback execution
- Empty stack pushes forward to trap back button and prevent exit

**stackRef Pattern:**
- Handler created once, accesses current values via ref
- Prevents handler recreation on every stack change
- Avoids stale closures and missed events

**Direct Atom Updates in Callbacks:**
- Callbacks update `activeFaceAtom` directly
- Avoids triggering write-only atom execution
- Simple and predictable state changes

---

## Consequences

### Positive

- ✅ **Back button works correctly** - Users can navigate backward through their actions
- ✅ **Never exits app** - Empty stack traps back button
- ✅ **Supports all navigation types** - Pages, dialogs, chat threads, AI navigation
- ✅ **Works with all back mechanisms** - Browser buttons, mouse shortcuts, mobile gestures
- ✅ **Maintainable** - Centralized logic, clear patterns
- ✅ **Debuggable** - Console logging shows stack operations
- ✅ **No URL pollution** - Maintains clean URLs without hash fragments
- ✅ **Cooperates with browser** - Works with native history API rather than fighting it

### Negative

- ⚠️ **Manual direction tracking required** - Developers must remember to use `direction: "forward"` for user actions
- ⚠️ **No browser forward button** - Only back navigation is supported (forward would require complex state prediction)
- ⚠️ **Memory overhead** - Each navigation stores a callback function (minimal in practice)
- ⚠️ **No persistence** - Navigation stack is lost on page refresh (acceptable for SPA)

### Trade-offs Accepted

- **Simplicity over features** - No forward button is acceptable for better back button UX
- **Developer ergonomics** - Manual direction parameter is worth it to prevent infinite loops
- **Memory vs functionality** - Small memory overhead is acceptable for full navigation support

---

## Validation

### Success Criteria

- ✅ Browser back button navigates backward through user actions
- ✅ Never exits application when pressing back
- ✅ Page navigation works (cube rotations)
- ✅ Dialog navigation works (project views, media viewers)
- ✅ Chat thread navigation works (new thread on back)
- ✅ AI-initiated navigation can be undone with back button
- ✅ Works in Chrome, Firefox, Safari, Edge
- ✅ Works on desktop, mobile, and tablet
- ✅ No infinite loops
- ✅ No page refreshes

### Testing Scenarios

| Scenario | Expected Behavior | Status |
|----------|-------------------|--------|
| Back on chat page (empty stack) | Stays in app | ✅ |
| Chat → Projects → Back | Returns to Chat | ✅ |
| Chat → Projects → Contact → Back → Back | Returns to Projects, then Chat | ✅ |
| Open project dialog → Back | Closes dialog | ✅ |
| Start chat → Back | Resets chat thread | ✅ |
| AI navigates to Resume → Back | Returns to previous page | ✅ |
| Back with mouse button 4 | Same as browser back | ✅ |
| Back on mobile swipe | Same as browser back | ✅ |

---

## Links and References

- [MDN - History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)
- [MDN - popstate event](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event)
- [Jotai - Write-only atoms](https://jotai.org/docs/guides/atoms-in-atom)
- Implementation details: `docs/implementation/navigation-system.md`

---

## Lessons Learned

### Technical Insights

1. **Centralized > Distributed** - Single navigation manager prevents race conditions and coordination issues that plague distributed hook approaches.

2. **Explicit Intent > Implicit Detection** - Direction parameters (`"forward"` | `"backward"`) prevent infinite loops better than trying to infer intent from state changes.

3. **Write-Only Atoms Are Actions** - In Jotai, write-only atoms (first parameter `null`) are functions to execute, not values to set. Callbacks must update state directly, not through write-only atoms.

4. **Cooperate With Browser, Don't Fight It** - After popstate, let the browser naturally go back in history. Only push forward when preventing app exit. Fighting the browser creates complex, brittle code.

5. **Side Effects Belong in Components** - DOM manipulation (`history.pushState`) should live in React components (via `useEffect`), not in atom logic. This follows React's mental model and keeps atoms pure.

6. **Refs Enable Stable Handlers** - The stackRef pattern allows event handlers to access current values without recreating the handler, preventing missed events and stale closures.

### Process Insights

1. **Iterate Through Failures** - Each failed approach revealed a new requirement or constraint that led to the final solution.

2. **User Feedback Drives Design** - Direct feedback about infinite loops and broken behavior highlighted architectural flaws that weren't apparent during initial implementation.

3. **Simplicity Emerges From Complexity** - The final solution is simple and elegant, but only after exploring complex alternatives that didn't work.

### Key Revelation

**State-based navigation requires explicit direction tracking.** In URL-based routing, forward vs backward is implicit (URL changed vs browser back). In state-based systems, both look like state updates. Without explicit direction, the system can't distinguish user actions from undo operations, causing infinite loops. This is a fundamental difference between URL-based and state-based navigation.
