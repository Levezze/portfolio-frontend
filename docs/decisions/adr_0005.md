# ADR 0005: Chat Security Measures

**Status:** Accepted
**Date:** 2025-10-11
**Decision Makers:** Development Team
**Related ADRs:** None

---

## Context and Problem Statement

The chat interface in our portfolio application accepts user input that is sent to an AI backend. Without proper security measures, the system is vulnerable to:

1. **Token Exhaustion Attacks** - Malicious users could spam messages to exhaust API tokens or overwhelm the backend
2. **Cross-Site Scripting (XSS)** - Injection of malicious scripts through chat input
3. **Prompt Injection** - Manipulation of AI behavior through crafted inputs
4. **HTML Injection** - Injection of arbitrary HTML that could affect page layout or functionality

### The Core Problem

User input is inherently untrusted and must be validated before processing. However, validation creates UX friction if not implemented thoughtfully.

**Key Questions:**
- How do we prevent abuse without degrading user experience?
- What validation rules balance security with usability?
- How do we provide clear feedback when input is rejected?

---

## Decision Outcome

### Chosen Solution: Defense-in-Depth Security

**Three-layer approach:**

1. **Rate Limiting** - Token Bucket algorithm (5 messages per minute)
2. **Input Validation** - Character whitelist with dangerous pattern detection
3. **Paste Sanitization** - DOMPurify to strip HTML from pasted content

**Implementation:**
- Client-side validation for UX (immediate feedback)
- Backend validation for security (cannot be bypassed)
- Visual warnings and disabled states for clear user feedback

---

## Implementation Details

### 1. Rate Limiting (Token Bucket)

**Configuration:**
```
Capacity: 5 tokens (messages)
Window: 60 seconds
Refill Rate: 1 token per 12 seconds
```

**Behavior:**
- User starts with 5 available messages
- Each sent message consumes 1 token
- Tokens refill gradually (1 every 12 seconds)
- Send button disabled when no tokens available
- Visual countdown shows time until next token

**Why Token Bucket?**
- Prevents burst attacks at window boundaries (unlike fixed windows)
- Smooth user experience (gradual refill vs hard resets)
- Industry standard for rate limiting

### 2. Input Validation

**Character Whitelist:**
```regex
/^[a-zA-Z0-9\s.,!?;:'"()\-@#$%&*+=/_\n\t]*$/
```

**Allowed:**
- English letters (a-z, A-Z)
- Numbers (0-9)
- Basic punctuation (.,!?;:)
- Common symbols (@#$%&*+=/-)
- Whitespace, newlines, tabs

**Blocked:**
- Emojis and Unicode special characters
- Non-Latin scripts (Cyrillic, Arabic, Chinese, etc.)
- HTML tags and entities
- Control characters

**Dangerous Pattern Detection:**
- `<script>` tags
- `<iframe>` tags
- `javascript:` protocol
- Event handlers (`onclick`, `onerror`, etc.)
- Any HTML tags

**Length Limit:** 2000 characters

### 3. Paste Sanitization

**Tool:** DOMPurify
**Configuration:** Strip ALL HTML tags, keep text content
**Trigger:** Only on paste events (not general input)

**Example:**
```
Input:  "<div>Hello <strong>World</strong></div>"
Output: "Hello World"
```

### 4. User Feedback

**Visual Components:**
- **RateLimitWarning** - Countdown timer when rate limited
- **CharacterCounter** - Real-time count with color coding (green/yellow/red)
- **ValidationError** - Inline error messages
- **Disabled Send Button** - Contextual tooltip explaining why

---

## Consequences

### Positive

**Security:**
- ✅ Prevents token exhaustion attacks
- ✅ Blocks XSS and script injection
- ✅ Mitigates prompt injection attempts
- ✅ Protects against Unicode exploits

**User Experience:**
- ✅ Immediate feedback on validation errors
- ✅ Clear explanation of rate limits
- ✅ Gradual token refill (not all-or-nothing)
- ✅ Visual indicators for all restrictions

**Maintainability:**
- ✅ Well-tested (47 tests, all passing)
- ✅ Reusable hooks (`useRateLimiter`, `useInputValidation`)
- ✅ Clear separation of concerns
- ✅ Documented for future developers

### Negative

**Limitations:**
- ❌ Blocks emojis (may frustrate some users)
- ❌ English-only (international users blocked)
- ❌ Rate limiting may feel restrictive to legitimate users
- ❌ Client-side validation can be bypassed (backend must duplicate)

**Trade-offs Accepted:**
- **No emojis** - Security > expressiveness for this use case
- **English-only** - Simplifies validation, acceptable for portfolio chat
- **Strict rate limit** - Better to be conservative, can relax later if needed

### Mitigation Strategies

**For blocked legitimate users:**
- Clear error messages explaining restrictions
- Contact form for feedback on limitations
- Future: Trusted user system with relaxed limits

**For international users:**
- English is expected for professional communication
- Contact form available as alternative
- Future: Could add multi-language support with proper Unicode handling

---

## Validation

### Success Criteria

- ✅ Rate limiting prevents >5 messages in 60 seconds
- ✅ Invalid characters rejected with clear error
- ✅ Pasted HTML stripped to plain text
- ✅ Send button disabled when rate limited or validation fails
- ✅ All security checks tested and passing

### Testing

**Unit Tests:** 47 tests (all passing)
- useRateLimiter: Token consumption, refill mechanics, persistence
- useInputValidation: Character validation, dangerous patterns, DOMPurify

**Test Coverage:**
- Token Bucket algorithm accuracy
- Regex validation correctness
- DOMPurify sanitization behavior
- Edge cases and error handling

**Manual Testing Checklist:**
- [ ] Send 6 messages rapidly → 6th blocked
- [ ] Wait 12 seconds after block → Can send again
- [ ] Type emoji → Validation error shown
- [ ] Paste HTML → Stripped to text
- [ ] Exceed 2000 chars → Error shown
- [ ] Type `<script>` → Blocked immediately

---

## Alternative Approaches Considered

### 1. Fixed Window Rate Limiting

**Rejected because:**
- Vulnerable to boundary attacks (send 5 at 0:59, 5 more at 1:01 = 10 in 2 seconds)
- Choppy UX (sudden reset vs gradual refill)

### 2. No Character Validation (Only Sanitization)

**Rejected because:**
- Sanitization alone allows Unicode exploits through
- Cannot block prompt injection attempts
- Less predictable (what gets through vs blocked?)

### 3. Allow All Unicode (Comprehensive Whitelist)

**Rejected because:**
- Complex to maintain (thousands of safe Unicode ranges)
- Higher attack surface (homoglyph attacks, etc.)
- English-only acceptable for this use case

### 4. No Rate Limiting (Trust Users)

**Rejected because:**
- Public-facing application cannot trust all users
- One malicious actor could exhaust resources
- Cost protection necessary for API calls

---

## Links and References

- **OWASP Top 10 for LLM Applications 2025**
- **Token Bucket Algorithm:** [Wikipedia](https://en.wikipedia.org/wiki/Token_bucket)
- **DOMPurify:** [GitHub Repository](https://github.com/cure53/DOMPurify)
- **Backend Coordination:** `.dev/chat-security-backend-spec.md`
- **Implementation Details:** `.dev/chat-security-implementation.md`

---

## Lessons Learned

1. **Defense-in-depth works** - Multiple layers catch what single layer misses
2. **UX matters in security** - Clear feedback reduces user frustration
3. **Test thoroughly** - Regex bugs are easy to introduce, hard to spot
4. **Document for backend** - Frontend security is UX; backend must enforce same rules
5. **Be conservative first** - Easier to relax restrictions later than tighten them

**Key Insight:** Client-side validation is for UX, not security. Always validate on backend.

---

## Future Considerations

### Potential Enhancements

1. **Trusted User System** - Relaxed limits for verified users
2. **Progressive Rate Limiting** - Increase restrictions after repeated violations
3. **Semantic Validation** - Use LLM to detect prompt injection attempts
4. **Multi-language Support** - Expand character whitelist with proper Unicode handling
5. **Content Filtering** - Optional profanity or PII detection

### Monitoring Recommendations

Track in production:
- Rate limit violation frequency
- Validation error types
- Character patterns blocked
- User feedback on restrictions

Alert thresholds:
- >100 rate limit violations/hour from single IP
- Unusual spike in validation errors
- Repeated attempts with dangerous patterns

---

## Status

**Implementation:** ✅ Complete
**Testing:** ✅ Complete (47/47 tests passing)
**Documentation:** ✅ Complete
**Backend Coordination:** ⏳ Pending (spec documented)

**Next Steps:**
1. Deploy frontend with security features
2. Implement backend validation (see backend spec)
3. Monitor metrics in production
4. Gather user feedback on restrictions
5. Adjust limits if needed based on real usage
