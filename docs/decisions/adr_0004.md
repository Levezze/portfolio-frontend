# ADR 0004: Mobile Keyboard Overlay Solution for 3D Transform Context

**Status:** Accepted
**Date:** 2025-10-08
**Decision Makers:** Development Team
**Related ADRs:** ADR 0002 (Responsive 3D Cube System)

---

## Context and Problem Statement

Our portfolio application displays pages as HTML faces on a 3D rotating cube using React Three Fiber and Drei's `<Html>` component. The chat and contact pages contain input fields that users interact with on mobile devices. When the mobile software keyboard opens, it overlays the bottom portion of the screen, completely covering the input fields and making them unusable.

### The Core Problem

**On mobile devices, the software keyboard overlays input fields, making them invisible and impossible to use.** The keyboard takes up 40-50% of the viewport height, covering the bottom half of the face content where inputs are located.

### Critical Constraint

**The 3D cube must remain visible at all times.** The cube is the central design element of the portfolio. Any solution that hides, removes, or significantly alters the cube's appearance was explicitly rejected. The cube's visual presence is non-negotiable.

### Technical Constraint: Transform3d Rendering Context

The Drei `<Html>` component uses CSS `transform: translate3d()` to position HTML content in 3D space. **This creates an isolated rendering context.** Elements inside a `transform3d` container:

- Cannot escape to viewport-relative positioning (like `position: fixed`)
- Cannot use viewport-relative sizing units effectively
- Cannot be portaled outside their rendering context without breaking 3D positioning
- Are confined to the coordinate space defined by the transform

This is a fundamental CSS limitation, not a library issue. From the [MDN documentation on containing blocks](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block):

> If the position property is `fixed`, the containing block is established by the viewport in most cases. However, if any ancestor has a `transform`, `perspective`, or `filter` property set to anything other than `none`, that ancestor becomes the containing block.

### Requirements

The solution must:

1. **Make inputs visible above the keyboard** - Users must be able to see what they're typing
2. **Keep the 3D cube visible** - The cube cannot disappear or be significantly altered
3. **Work within transform3d constraints** - Cannot rely on escaping the rendering context
4. **Maintain focus and form state** - No re-renders or focus loss during keyboard transitions
5. **Provide context** - Users should see field labels, not just input boxes
6. **Be maintainable** - Simple, predictable solution without complex workarounds

---

## Failed Approaches

Through extensive iteration, multiple approaches were attempted and failed due to the transform3d rendering context constraint.

### 1. CSS-Based Dynamic Height Constraints

**Commits:** `c1fb891`, `352496a`, `6e95e8b` (all later reverted in `2470730`)

**Approach:**
- Track `visualViewport.height` changes via JavaScript
- Apply `max-height` constraints to face content when keyboard opens
- Use CSS custom properties (`--viewport-current-height`) to cap content height
- Enable `overflow-y: auto` to create scrollable area

**Implementation:**
```css
.keyboard-adjusted {
  max-height: var(--viewport-current-height);
  overflow-y: auto;
}
```

**Problem:**
- CSS vars updated correctly, classes toggled correctly
- **But no layout reflow occurred** - content reported original height
- The `transform3d` on the `<Html>` component prevented viewport-relative sizing from affecting layout
- Browser drew keyboard overlay without changing the transformed element's layout
- Auto-scroll logic fired but container remained centered within cube face
- Transform context limits scroll effectiveness

**User observation:** *"No matter what I did, the `transform` of the Html component did not allow me to decouple CSS sizing from the actual 3D faces"*

### 2. Floating Input Mirrors in Portal (Centralized)

**Commits:** `778b94f` (implemented), `b202c4d` (reverted)

**Approach:**
- Create `FloatingInputMirror.tsx` component mounted at document root
- Detect focused inputs via global focus events
- Clone/mirror input element in a `position: fixed` portal above keyboard
- Manually synchronize values between original and mirrored inputs

**Implementation:**
```tsx
// FloatingInputMirror.tsx - centralized portal
<div style={{ position: 'fixed', bottom: 0, zIndex: 9999 }}>
  <input value={mirroredValue} onChange={syncToOriginal} />
</div>
```

**Problem:**
- **Manual value synchronization was fragile** - had to intercept onChange events
- **Complex state coordination** - form libraries (react-hook-form, @assistant-ui) didn't know about mirrors
- **Focus management issues** - switching focus between original and mirror broke form state
- **Validation problems** - mirrors bypassed form validation contexts
- Removed 101 lines in revert commit

**Why it failed:** Centralized approach couldn't handle different form architectures (react-hook-form vs @assistant-ui context).

### 3. Floating Input Portals (Decentralized, Per-Component)

**Commits:** `f630b8a`, `29f7e44`, `1a2a3bf` (implemented), `be212ae` (refined), `b202c4d` (all reverted)

**Approach:**
- Abandon centralized mirror, implement per-component
- Portal duplicate input components directly in chat and contact forms
- Use shared state architecture (react-hook-form instance, @assistant-ui context)
- Render floating portal when keyboard visible, duplicate entire input component

**Implementation:**
```tsx
// Chat: Portal ComposerPrimitive.Input when keyboard visible
{keyboardVisible && createPortal(
  <div className="floating-input-container">
    <ComposerPrimitive.Input autoFocus className="floating-input" />
  </div>,
  document.body
)}

// Contact: Portal FormField components when keyboard visible
{keyboardVisible && createPortal(
  <FormField control={form.control} name="email">
    {/* Duplicate field with shared state */}
  </FormField>,
  document.body
)}
```

**Problem:**
- **Re-render loops** - Portal mounting caused component re-renders
- **Focus loss** - When keyboard opened, portal mounted, DOM nodes moved, focus lost
- **Keyboard close triggers** - Blur events from focus loss closed keyboard
- **Infinite cycle:** Tap input → keyboard opens → portal mounts → DOM moves → focus lost → blur fires → keyboard closes → portal unmounts → repeat
- **Form context duplication issues** - Even with shared state, duplicate components created validation conflicts
- Removed 519 lines in revert commit

**User feedback:** *"Of course, nothing fucking works. Pressing the inputs just re-renders the entire component."*

### 4. Portal Entire Face When Keyboard Visible

**Commits:** Never committed (live experiment), cleanup in `c85edda`

**Approach:**
- Portal the entire `Face` component (with all content) to `document.body` when keyboard opens
- This would escape the transform3d context completely
- Face would render at viewport level, allowing responsive CSS to work

**Conceptual implementation:**
```tsx
// Face.tsx
{isMobile && keyboardVisible ? (
  createPortal(<div className="face-content">{children}</div>, document.body)
) : (
  <div className="face-content">{children}</div>
)}
```

**Problem:**
- **The 3D cube disappeared entirely** - Portaling the face removed it from the 3D scene
- Only the portaled content was visible, floating in 2D at document level
- **Completely broke the central design concept** of the application
- The cube is the portfolio's defining feature - making it disappear was unacceptable

**User feedback:** *"Wait you must be fucking kidding me. NO.... I thought that you only make the input appear (opacity 0 to 100) via the portal when necessary. Not that the ENTIRE FUCKING APP DISAPPEARS... ABSOLUTELY FUCKING NOT."*

**Why it failed:** Violates the non-negotiable requirement that the cube must remain visible.

### 5. AI Suggestion: Accept Keyboard Overlay or Abandon 3D Cube

**Approach:** Two options presented:
1. Accept that keyboard overlays inputs (poor UX)
2. Render CSS-only layout on mobile, abandon 3D cube (destroys app concept)

**Problem:**
- Option 1: Unusable - users can't see or interact with covered inputs
- Option 2: Defeats entire purpose - portfolio is designed around the 3D cube

**User response:** Rejected both options and developed the final solution independently.

---

## Decision Outcome

### Chosen Solution: Dynamic Bottom Padding + ScrollIntoView

**User-developed solution that works within transform3d constraints rather than fighting them.**

**Core Principle:** Instead of trying to escape the rendering context, create enough scrollable space *within* the context to bring inputs above the keyboard.

### Architecture

**1. Dynamic Padding (60dvh)**

When keyboard is visible on mobile, add large bottom padding to scrollable containers:

```tsx
// Conditional padding applied to scroll containers
className={cn(
  "overflow-y-auto",
  isMobile && keyboardVisible && "pb-[60dvh]"
)}
```

**Why 60dvh:**
- Mobile keyboards typically occupy 40-50% of viewport height
- 60dvh ensures comfortable space above keyboard (input + context visible)
- Dynamic viewport height (`dvh`) adapts to actual available space
- Creates scrollable "empty zone" at bottom of content

**2. ScrollIntoView on Focus**

When user focuses an input, scroll it (and its context) into view:

```tsx
// Contact form: Scroll entire FormItem (label + input + validation)
useEffect(() => {
  if (!isMobile) return;

  const handleFocus = (e: FocusEvent) => {
    const target = e.target as HTMLElement;
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
      // Find parent FormItem that contains label and input
      const formItem = target.closest('[data-slot="form-item"]');

      setTimeout(() => {
        if (formItem) {
          formItem.scrollIntoView({
            behavior: "smooth",
            block: "start",
            inline: "nearest",
          });
        }
      }, 350); // Delay ensures keyboard animation completes
    }
  };

  wrapper.addEventListener("focusin", handleFocus);
  return () => wrapper.removeEventListener("focusin", handleFocus);
}, [isMobile]);
```

### Implementation

**Chat Component (`src/components/scene/chat/assistant-ui/thread.tsx`)**

```tsx
export const Thread: FC = () => {
  const isMobile = useAtomValue(isMobileAtom);
  const keyboardVisible = useAtomValue(keyboardVisibleAtom);

  return (
    <ThreadPrimitive.Viewport className={cn(
      "aui-thread-viewport relative flex flex-1 flex-col overflow-x-auto overflow-y-auto",
      isMobile && keyboardVisible && "pb-[60dvh]"
    )}>
      {/* Chat content */}
    </ThreadPrimitive.Viewport>
  );
};
```

**Why chat doesn't need ScrollIntoView:** The `@assistant-ui` library has built-in scroll-to-bottom behavior that handles bringing the composer input into view automatically.

**Contact Form (`src/components/scene/contact/ContactForm.tsx`)**

```tsx
const ContactForm = () => {
  const isMobile = useAtomValue(isMobileAtom);
  const keyboardVisible = useAtomValue(keyboardVisibleAtom);
  const wrapperRef = useRef<HTMLDivElement>(null);

  // Scroll focused input into view
  useEffect(() => {
    if (!isMobile) return;

    const handleFocus = (e: FocusEvent) => {
      const target = e.target as HTMLElement;
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
        const formItem = target.closest('[data-slot="form-item"]');

        setTimeout(() => {
          if (formItem) {
            formItem.scrollIntoView({
              behavior: "smooth",
              block: "start",
              inline: "nearest",
            });
          } else {
            target.scrollIntoView({
              behavior: "smooth",
              block: "start",
              inline: "nearest",
            });
          }
        }, 350);
      }
    };

    const wrapper = wrapperRef.current;
    if (wrapper) {
      wrapper.addEventListener("focusin", handleFocus);
      return () => wrapper.removeEventListener("focusin", handleFocus);
    }
  }, [isMobile]);

  return (
    <div
      ref={wrapperRef}
      className={cn(
        "flex flex-col items-center justify-start h-full w-full px-2 pt-2 gap-2 overflow-y-auto",
        isMobile && keyboardVisible && "pb-[60dvh]"
      )}
    >
      {/* Form fields */}
    </div>
  );
};
```

**Why contact needs explicit ScrollIntoView:** Form fields are static - there's no automatic scroll behavior. Each input focus must trigger explicit scroll to bring the FormItem (label + input + validation) into view.

**Keyboard Detection (`src/hooks/useViewportMetrics.ts`)**

```tsx
useEffect(() => {
  if (typeof window === "undefined" || !window.visualViewport) return;

  const handleResize = () => {
    const vv = window.visualViewport;
    if (!vv) return;

    const windowHeight = window.innerHeight;
    const viewportHeight = vv.height;

    // Keyboard is visible when visualViewport shrinks significantly
    const keyboardHeight = windowHeight - viewportHeight;
    const isKeyboardVisible = keyboardHeight > 150; // Threshold for keyboard detection

    setKeyboardVisible(isKeyboardVisible);
  };

  window.visualViewport.addEventListener("resize", handleResize);
  return () => window.visualViewport?.removeEventListener("resize", handleResize);
}, [setKeyboardVisible]);
```

### Why This Works

**1. Respects Transform3d Context**
- Doesn't try to escape the rendering context
- Works entirely within the transformed coordinate space
- No portals, no position: fixed, no viewport-relative sizing

**2. No DOM Movement**
- Elements stay in their original positions
- No mounting/unmounting of components
- No focus loss or re-render loops

**3. Uses Browser Native APIs**
- `scrollIntoView()` is well-supported and reliable
- Smooth behavior works across browsers
- Browser handles the scroll animation

**4. Provides Context**
- Scrolls entire FormItem (label + input + validation message)
- Users see what field they're filling out
- Better UX than scrolling just the input box

**5. Simple and Maintainable**
- Two-line className change for padding
- Standard event listener pattern for scroll
- No complex state management or synchronization

**6. Cube Remains Visible**
- Face content scrolls within the 3D face
- Cube stays in place, fully visible
- Satisfies the non-negotiable design requirement

---

## Consequences

### Positive

- ✅ **Inputs visible above keyboard** - Users can see and interact with form fields
- ✅ **Cube remains visible** - Central design element preserved
- ✅ **No focus loss** - Inputs maintain focus during keyboard transitions
- ✅ **No re-renders** - Stable, predictable behavior
- ✅ **Provides context** - Labels and validation visible with inputs
- ✅ **Simple implementation** - Minimal code, easy to understand
- ✅ **Maintainable** - No complex workarounds or fragile synchronization
- ✅ **Works within constraints** - Respects transform3d rendering context
- ✅ **Performant** - Native browser scroll, no JavaScript animation

### Negative

- ⚠️ **Mobile-specific code** - Desktop doesn't need this behavior
- ⚠️ **Magic number (60dvh)** - Empirically determined, not calculated
- ⚠️ **Timing dependency** - 350ms delay assumes keyboard animation duration
- ⚠️ **Only works for scrollable containers** - Requires overflow-y: auto

### Trade-offs Accepted

- **Platform-specific vs universal** - Mobile needs different behavior, that's acceptable
- **Fixed padding vs dynamic calculation** - 60dvh works reliably, calculation would add complexity
- **Timeout vs event-based** - No keyboard animation complete event exists, timeout is necessary
- **Scroll requirement vs static layout** - Scrolling is natural on mobile, acceptable trade-off

---

## Validation

### Success Criteria

- ✅ Keyboard opens without covering inputs
- ✅ Users can see field labels and validation messages
- ✅ Typing works smoothly without focus loss
- ✅ Cube remains visible throughout interaction
- ✅ Works on iOS Safari and Android Chrome
- ✅ No re-render loops or performance issues
- ✅ Form submission works correctly
- ✅ Tabbing between fields scrolls appropriately

### Testing Scenarios

| Scenario | Expected Behavior | Status |
|----------|-------------------|--------|
| Focus name input in contact form | FormItem scrolls into view, label visible | ✅ |
| Focus email input | Email FormItem scrolls, name scrolls out of view | ✅ |
| Focus message textarea | Textarea and label visible above keyboard | ✅ |
| Type in chat composer | Input visible, send button accessible | ✅ |
| Tab between contact form fields | Each field scrolls into view on focus | ✅ |
| Keyboard opens/closes rapidly | No focus loss, smooth transitions | ✅ |
| Rotate device with keyboard open | Keyboard closes, layout adapts correctly | ✅ |
| Submit contact form | Form validates and submits correctly | ✅ |

---

## Links and References

- [MDN - Containing Block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)
- [MDN - Visual Viewport API](https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API)
- [MDN - Element.scrollIntoView()](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)
- [CSS Transform Rendering Context](https://www.w3.org/TR/css-transforms-1/#transform-rendering)
- Implementation details: `docs/implementation/mobile-keyboard-handling.md`
- Related: `.dev/notes/mobile-keyboard-debug.md` (early CSS attempts)

---

## Lessons Learned

### Technical Insights

1. **Transform3d Creates Isolated Rendering Context** - This is a fundamental CSS constraint, not a library limitation. Any element with `transform`, `perspective`, or `filter` becomes a containing block for positioned descendants. You cannot escape this context with `position: fixed` or viewport-relative units.

2. **Work With Constraints, Not Against Them** - After multiple failed attempts to escape the transform context (portals, fixed positioning), the solution was to work *within* the constraint by creating scrollable space.

3. **Native Browser APIs Are Powerful** - `scrollIntoView()` handles all the complexity of scroll positioning, animation, and edge cases. No need to reimplement scroll logic in JavaScript.

4. **React Portals Break 3D Contexts** - Portaling content out of a 3D scene removes it from the scene. Even portaling individual elements breaks their spatial relationship with the 3D environment.

5. **Keyboard Detection Is Reliable** - The VisualViewport API provides accurate keyboard state via height changes. A simple threshold (150px) reliably detects keyboard open/close.

6. **Form Context Matters** - FormItem-level scrolling (vs input-only) provides critical context for users. Labels and validation messages must remain visible.

### Process Insights

1. **Constraints Reveal Solutions** - The transform3d constraint eliminated entire categories of solutions, forcing creative thinking that led to the elegant final approach.

2. **User Knowledge Is Critical** - The user's understanding of the design requirements (cube must stay visible) prevented wasteful exploration of non-viable solutions.

3. **Rapid Iteration Uncovers Edge Cases** - The floating portal approach seemed promising initially but real-device testing revealed focus loss and re-render issues immediately.

4. **Simple Solutions After Complex Failures** - The final solution is remarkably simple (conditional padding + scrollIntoView), but only emerged after exploring complex alternatives.

5. **Document Failures Honestly** - Recording what didn't work and why prevents future developers from repeating failed experiments.

### Key Revelation

**CSS transform contexts are rendering boundaries that JavaScript cannot cross.** Many "clever" solutions (portals, fixed positioning, viewport units) fundamentally cannot work within transformed coordinate spaces. The solution must respect the rendering context and work within its constraints.

This is similar to the lesson from ADR 0003 (Navigation System): **you cannot fight the browser's fundamental architecture.** Instead, cooperate with it and design solutions that work within its constraints.

### User Innovation

**The final solution was developed entirely by the user after the AI suggested two unacceptable options** (accept keyboard overlay or abandon 3D cube). This demonstrates the value of domain knowledge and creative problem-solving within constraints.

The user correctly identified that:
- The problem isn't *lack* of space, it's *placement* of space
- Adding scrollable space *inside* the context works where escaping *outside* fails
- Simple padding + native scroll is more reliable than complex state synchronization

This solution is elegant precisely because it's simple, maintainable, and works with the browser rather than against it.
